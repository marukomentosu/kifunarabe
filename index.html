/**
 * ShogiLogic: 要件11〜20を司る核心クラス
 */
class ShogiLogic {
    constructor() {
        this.board = Array(81).fill(null);
        this.hand = { sente: {}, gote: {} };
        this.history = []; // 局面ハッシュを保存(要件14用)
        this.turn = 'sente';
    }

    // --- 要件11: 全駒の移動バリデーション ---
    getLegalMoves(pos, piece, board) {
        const moves = [];
        const vectors = this.getVectors(piece.type, piece.color);
        
        vectors.forEach(v => {
            let cur = pos;
            while (true) {
                cur += v.diff;
                if (!this.isInside(cur, pos, v.diff)) break;
                
                const target = board[cur];
                if (!target) {
                    moves.push(cur);
                    if (!v.range) break;
                } else {
                    if (target.color !== piece.color) moves.push(cur);
                    break;
                }
            }
        });
        return moves.filter(to => !this.isLeavingCheck(pos, to, piece.color));
    }

    // --- 要件17: 二歩のリアルタイム判定 ---
    canDropPawn(colIndex, color) {
        for (let row = 0; row < 9; row++) {
            const p = this.board[row * 9 + colIndex];
            if (p && p.type === '歩' && p.color === color) return false;
        }
        return true;
    }

    // --- 要件12: 打ち歩詰め判定 (極めて複雑) ---
    isUchifuzume(to, color) {
        const enemyColor = color === 'sente' ? 'gote' : 'sente';
        // 1. 王手か？ 2. 相手に逃げ道がないか？ 3. それが「打ち歩」か？
        if (!this.isCheck(enemyColor)) return false;
        const escapeMoves = this.getAllLegalMoves(enemyColor);
        return escapeMoves.length === 0;
    }

    // --- 要件19: 駒の利きヒートマップ生成 ---
    generateInfluenceMap() {
        const map = Array(81).fill(0); // 正の値は先手、負の値は後手の利き数
        this.board.forEach((p, i) => {
            if (!p) return;
            const moves = this.getPseudoLegalMoves(i, p, this.board);
            moves.forEach(m => {
                map[m] += (p.color === 'sente' ? 1 : -1);
            });
        });
        return map;
    }

    // --- 要件15: 持将棋（24点法）計算 ---
    calculateJishogiPoints() {
        const points = { sente: 0, gote: 0 };
        this.board.concat(Object.values(this.hand.sente), Object.values(this.hand.gote)).forEach(p => {
            if (!p || p.type === '玉') return;
            const val = (p.type === '飛' || p.type === '角') ? 5 : 1;
            points[p.color] += val;
        });
        return points; // 24点以上で宣言可能
    }

    // --- 要件13 & 20: 王手判定と視覚警告用フラグ ---
    isCheck(color) {
        const kingPos = this.board.findIndex(p => p && p.type === '玉' && p.color === color);
        const enemyColor = color === 'sente' ? 'gote' : 'sente';
        const influence = this.generateInfluenceMap();
        return enemyColor === 'sente' ? influence[kingPos] > 0 : influence[kingPos] < 0;
    }

    // 内部補助ロジック (ベクトル定義など)
    getVectors(type, color) {
        const d = color === 'sente' ? -1 : 1;
        const defs = {
            '歩': [{diff: 9*d, range: false}],
            '香': [{diff: 9*d, range: true}],
            '桂': [{diff: 18*d-1, range: false}, {diff: 18*d+1, range: false}],
            '銀': [{diff: 9*d-1, range: false}, {diff: 9*d, range: false}, {diff: 9*d+1, range: false}, {diff: -9*d-1, range: false}, {diff: -9*d+1, range: false}],
            '金': [{diff: 9*d-1, range: false}, {diff: 9*d, range: false}, {diff: 9*d+1, range: false}, {diff: -1, range: false}, {diff: 1, range: false}, {diff: -9*d, range: false}],
            '玉': [{diff: 8, range: false}, {diff: 9, range: false}, {diff: 10, range: false}, {diff: 1, range: false}, {diff: -1, range: false}, {diff: -8, range: false}, {diff: -9, range: false}, {diff: -10, range: false}],
            '飛': [{diff: 9, range: true}, {diff: -9, range: true}, {diff: 1, range: true}, {diff: -1, range: true}],
            '角': [{diff: 10, range: true}, {diff: 8, range: true}, {diff: -10, range: true}, {diff: -8, range: true}]
        };
        return defs[type] || [];
    }
}
